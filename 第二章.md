### 第二章

---

[笔记](#笔记)

​	[2.浮点数](#floating)

[习题](#习题)

[家庭作业](#家庭作业)(难度为\*\*\*\*单独链接)

- [2.65](#2.65)

---

笔记

- 提要：这章的内容是关于数据的存储方式和操作方法，不需要什么基础

1. 表示方法

   - 二进制、十进制、十六进制表示法

2. 存储方式

   - 通常一个最小的内存单元"块"是8byte(8个二进制数，如果用十六进制就是2个)

   - 字长：就是32位和64位，代表最大地址+1的幂指数

   - 寻址方式和字节顺序

     - 寻址方式就是找到基地址，然后递增到这个信息结束

     - 字节顺序分为两种，分别是little endian和big endian，比如0x87654321在两种方式中的字节顺序如下表所示(顺带一提，书上都是big，但是我的系统是little......)

       |        | base | base+1 | base+2 | base+3 |
       | ------ | ---- | ------ | ------ | ------ |
       | little | 21   | 43     | 65     | 87     |
       | big    | 87   | 65     | 43     | 21     |

3. 布尔代数

   - 就是bool及运算(&, |, ~, \^)，其中^的性质很有意思，可以看看
   - 这玩意儿在定长的时候，关于~以外的三个运算都可以构成一个ring
   - 作用之一是掩码
   - 位运算还有移位操作，分为左移和右移，左移一律补0
     - 右移分为算术右移和逻辑右移，逻辑右移补0，算术右移按照最高位补相同数字，可以证明

4. 整数

   - 在C99加入了int64_t，但通常的int指的还是32位二进制补码表示法
   - 如何表示正负？
     - 通常使用补码表示法(首位负权)，可以证明对于整数x, ~x+1 = -x
     - 也可以使用原码和反码，缺点是这两种表示方法中的0有两种表示方法，而且运算性质不好
   - 溢出
     - 当运算数值超出了32位表示范围就会产生溢出，从而造成影响。溢出后数字会发生截断，保留末32位(当然这并不正常)
     - unsigned和相应的signed类型进行运算时会发生类型转换，转换为signed类型，出现错误
     - 可以提前判断溢出，例如转换为64位后转回，然后判断是否发生截断；或者直接计算也可以
     - 乘法运算可以分解为移位和或差，例如14\*x = (x<<3) + (x<<2) + (x<<1) = (x<<4) - (x<<1)，具体得看compiler的智商
     - 除法运算很慢，但是除以2的幂可以转化成移位

---

浮点<span id = "floating">数</span>

- 浮点数的表示方法？

  - 我们已经知道，计算机中的所有数都是以二进制编码的形式储存(除了宾夕法尼亚大学的某台用10个管子显示数字的笨蛋计算机)

    但是以这种方式存储十进制小数一定会有误差，所以只能做到近似模拟

  - 具体组成：IEEE标准的浮点数由以下三个部分组成

    - 符号位s: 像int一样，第一位作为符号位
    - k位数字e，表示阶数E: 用来表示2的幂次。其中float通常为8位，double为11位
    - n位小数位f，用来表示尾数M

  - 表示方法

    - 符号位0为正，1为负
    - 阶数不全为0或不全为1时，表示非规格化的值，此时尾数M=1.f，Bias = 2^k-1^-1，E=e-Bias(也就是E的范围里正数比负数多一个)，数字为M\*2^E^; 当阶数全为1时，若f=0，表示无穷，否则表示NaN; 当阶数全为0时，数字=尾数M=0.f，E=1-Bias(这样可以获得更高的小数精度)

  - 舍入：通常采用的是向最接近的数舍入，否则向偶数舍入(为了无偏)

- 浮点数的运算

  - 浮点数加法的性质非常差，因为舍入会造成误差，所以浮点数运算是不满足结合律的(不构成群，也就是说是个非常烂的代数系统)


---

习<span id = "习题">题</span>

- 练习2.5,11,12,13,15,23,25,26

  ```c
  #include<stdio.h>
  #include<string.h>
  typedef unsigned char* byte_pointer;
  
  /*练习2.5
   *练习2.11很容易。原因是两个指针指向了相同的地址。 
   *练习2.12 
   *练习2.13
   *(1)bis(x,y)
   *(2)bis( bic(x,y), bic(y,x) )
   *练习2.15 !(x^y), 通过异或性质(元素加法逆元为自身)
   *练习2.23 保留最后8位, 得到其表示的数值的signed形式(通常都会是算术位移，前面有练习证明了算术位移不会改变signed类型的数值) 
   *练习2.25 由于length的类型为unsigned, 所以当length为0时，length-1并不是-1, 会访问a为基地址的之后的所有内存
   *练习2.26 直接对两个string的strlen进行比较即可, 否则会因为它们的差小于0导致溢出 
   */
  	 
  
  void show_byte(byte_pointer start, size_t len)
  {
  	size_t i;
  	for(i = 0; i < len; ++i)
  	{
  		printf("%.2x", start[i]);
  	}
  	printf("\n");
  }
  
  void show_int(int x)
  {
  	show_byte((byte_pointer) &x, sizeof(int));
  }
  
  void show_float(float x)
  {
  	show_byte((byte_pointer) &x, sizeof(float));
  }
  
  void show_int(void* x)
  {
  	show_byte((byte_pointer) &x, sizeof(void*));
  }
  
  void change_1(byte_pointer x, int len)
  {
  	for(size_t i = 1; i < len; ++i)
  	{
  		x[i] = 0;
  	}
  }
  
  void change_2(byte_pointer x, int len)
  {
  	for(size_t i = 1; i < len; ++i)
  	{
  		x[i] = ~x[i];
  	}
  }
  
  void change_3(byte_pointer x)
  {
  	x[0] = 0xff;
  }
  
  
  
  int main()
  {
  	int val = 0x87654321;
  	byte_pointer valp = (byte_pointer)&val;
  	change_2(valp, sizeof(int));
  	printf("%d\n", val);//可以确定储存方式是low endian 
  	show_byte(valp, 1);
  	show_byte(valp, 2);
  	show_byte(valp, 3);
  	
  	const char* s = "abcdef";
  	show_byte((byte_pointer)&s, strlen(s));
  	return 0;
  }
  
  //小端法表示 
  ```

- 练习2.29, 30, 31, 32, 36,37, 42,43

  ```C
  #include<bits/stdc++.h>
  using namespace std;
  
  //练习2.29和2.30
  //练习2.31 这个函数的返回值永远是1
  //练习2.32 同tadd_ok的条件。原来的代码会在参数为-1, -2147483648时出错 
  //练习2.36 判断int64_t转换为int发生截断时是否对数值造成影响 
  //练习2.37 不会解决, 我的建议是不要解决, 分配空间太大直接报错 
  //练习2.42 要考虑怎么才能直接获得bias(考虑掩码过滤) 
  //练习2.43 N=8, M=31 
  
  //用减法替代加法 
  int uadd_ok(unsigned x, unsigned y)
  {
  	if(0xffffffff-x>=y)
  		return 1;
  	else return 0;
  }
  
  int tadd_ok(int x, int y)
  {
  	if((x > 0 && y > 0 && x+y < 0) || (x < 0 && y < 0 && x+y > 0))
  		return 0;
  	return 1;
  }
  
  int tmult_ok(int x, int y)
  {
  	int64_t judge = (int64_t)x*y;
  	if(judge == int(judge))
  		return 1; 
  	return 0;
  }
  
  int div16(int num)
  {
  	int bias = (num >> 31) & 0xF;
  	return (num+bias) >> 4;
  }
  
  int main()
  {
  	cout << div16(-17);
  	return 0;
  }
  ```

  

练习2.48 首先将一个整数写为二进制表示法，此时其二进制位为w，则E=w-1+127，符号位与该整数相同，整数位右移w-1位后小数部分就是floating的小数部分

练习2.52

| 格式A   |       | 格式B   |      | 注               |
| ------- | ----- | ------- | ---- | ---------------- |
| 位      | 值    | 位      | 值   |                  |
| 0110000 | 1     | 0111000 | 0    |                  |
| 1011110 | 15/2  | 1001111 | 15/2 |                  |
| 0101001 | 25/32 | 0110100 | 3/4  | 向下舍入         |
| 1101111 | 31/2  | 1011000 | 16   | 向上舍入         |
| 0000001 | 1/64  | 0001000 | 1/64 | 非规格化->规格化 |

练习2.53

- POS_INFINITY 1e1000
- NEG_INFINITY (-POS_INFINITY)
- NEG_ZERO (-1.0/POS_INFINITY)

练习2.54

1. 始终为真，double可以精确表示所有的int
2. x = 1e10，这个数值超过了float的表示范围并产生溢出
3. d = 1e10，这个数值超过了float的表示范围并产生溢出
4. 始终为真，double可以精确表示所有的float
5. 始终为真，floating取负只是改变符号位
6. 始终为真，因为会先进行强制类型转换
7. 假，可能会造成舍入，例如当f = 1e20， d = 1
   - 这里已经超出了float和double可以精确表示的范围了(double大概15-17位)

---

<span id = "家庭作业">家庭作业</span>

2.55, 56, 57上面已经试过了哦，并且可以在Linux环境下运行

2.58, 59, 60 事实上现在通用的字长没几种吧，练习2.60是在little endian机器上运行的，我很欣慰

```C
#include<stdio.h>

int is_little_endian()
{
	int test = 0x87654321;
	int *ptr;
	ptr = &test;
	char* p;
	p = (char*)ptr;
	if(*p == 0x21) return 0;
	else return 1;
}

unsigned replace_byte(unsigned x, int i, unsigned char b)
{
	char* ptr = ((char*)&x)+i;
	*ptr = b;
	return x;
} 

int main()
{
	printf("%d", is_little_endian());
	int x = 0x89ABCDEF, y = 0x76543210;
	printf("\n%d\n%d\n", x, y);
	*((char*)&y) = *((char*)&x);//练习2.59 
	printf("\n%x\n", y);
	printf("%x", replace_byte(0x12345678,0,0xAB));
	return 0;
}
```

接下来的题目中，只能使用位运算、逻辑运算、位移、等于测试、加减、整型常数INT_MAX和INT_MIN，和对int与unsigned进行的类型转换

注意你不可以使用循环！！！

2.61-64，63有点难度

```c
#include<bits/stdc++.h>
using namespace std;

int Expression_A(int x)
{
	return !(x+1);//全为1->x+1全为0 
}

int Expression_B(int x)
{
	return !x;
}

int Expression_C(int x)
{
	return !(*(char*)&x+1);
}

int Expression_D(int x)
{
	return !*((char*)&x+(sizeof(x)-1));
}

int int_shifts_are_arithmetic()//2.62 
{
	int x = 0xffffffff;//这时x是一个各位为1的数 
	x >> 8;
	char* valp = (char*)&x;
	return !(*valp == 0);//算术右移时*valp全为1，否则全为0 
}

unsigned srl(unsigned x, int k)//练习2.63，思路是掩码 
{
	unsigned xsra = (int) x >> k;
	int w = 8*sizeof(int);
	int z = (1 << (w-k))-1;
	return xsra & z;
}

int sra(int x, int k)
{
	int xsrl = (unsigned) x >> k;
	int w = 8*sizeof(int);
	int z = (1 << (w-k-1));
	z = !!(z & xsrl);//完成后，如果x最高位是1，那么z为1，否则z为0
	z = ~((z << (w-k))-1);//构造掩码 
	return z | xsrl; 
}

int any_odd_one(unsigned x)//练习2.64，知道了w就随便写了 
{
	return !!(0xaaaaaaaa & x);
}

int main()
{
	int x = 0xffffffff;
	cout << Expression_A(x) << ends;
	cout << Expression_B(x) << ends;
	cout << Expression_C(x) << ends;
	cout << Expression_D(x) << ends;
	cout << srl(x,24) << endl;
	cout << sra(x,24) << endl;
	cout << any_odd_one(x) << endl; 
	return 0;
}
```

---

<span id = "2.65">练习2.65</span> 如下所示

```C
#include<bits/stdc++.h>
using namespace std;

int odd_ones(int x)
{
	//要求:x长32位。使用不超过12个运算，判断x的二进制位中是否有奇数个1.
	//12步实际上已经把方法限制到二分了 
	//如果对两个长为z的数x1和x2使用^，得到的结果和原来两数中1的奇偶性有什么关系?
	//我们可以证明 与x1和x2的1个数之和的奇偶性相同 
	//我们可以每次位移一半，然后得到结果
	x = (x << 16) ^ x;
	x = (x << 8 ) ^ x;
	x = (x << 4 ) ^ x;
	x = (x << 2 ) ^ x;
	x = (x << 1 ) ^ x;
	return (x >> 31) & 1; 
}

int main()
{
	int x = 0xb11ab11a;
	cout << odd_ones(x);
	return 0;
}
```

