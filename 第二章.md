### 第二章

---

[笔记](#笔记)

[习题](#习题)

---

笔记

- 提要：这章的内容是关于数据的存储方式和操作方法，不需要什么基础

1. 表示方法

   - 二进制、十进制、十六进制表示法

2. 存储方式

   - 通常一个最小的内存单元"块"是8byte(8个二进制数，如果用十六进制就是2个)

   - 字长：就是32位和64位，代表最大地址+1的幂指数

   - 寻址方式和字节顺序

     - 寻址方式就是找到基地址，然后递增到这个信息结束

     - 字节顺序分为两种，分别是little endian和big endian，比如0x87654321在两种方式中的字节顺序如下表所示(顺带一提，书上都是big，但是我的系统是little......)

       |        | base | base+1 | base+2 | base+3 |
       | ------ | ---- | ------ | ------ | ------ |
       | little | 21   | 43     | 65     | 87     |
       | big    | 87   | 65     | 43     | 21     |

3. 布尔代数

   - 就是bool及运算(&, |, ~, \^)，其中^的性质很有意思，可以看看
   - 这玩意儿在定长的时候，关于上述四个运算构成一个ring
   - 作用之一是掩码
   - 位运算还有移位操作，分为左移和右移，左移一律补0
     - 右移分为算术右移和逻辑右移，逻辑右移补0，算术右移按照最高位补相同数字，可以证明
   
4. 整数

   - 在C99加入了int64_t，但通常的int指的还是32位二进制补码表示法
   - 如何表示正负？
     - 通常使用补码表示法(首位负权)，可以证明对于整数x, ~x+1 = -x
     - 也可以使用原码和反码，缺点是这两种表示方法中的0有两种表示方法，而且运算性质不好
   - 溢出
     - 当运算数值超出了32位表示范围就会产生溢出，从而造成影响。溢出后数字会发生截断，保留末32位(当然这并不正常)
     - unsigned和相应的signed类型进行运算时会发生类型转换，转换为signed类型，出现错误
     - 可以提前判断溢出，例如转换为64位后转回，然后判断是否发生截断；或者直接计算也可以
     - 乘法运算可以分解为移位和或差，例如14\*x = (x<<3) + (x<<2) + (x<<1) = (x<<4) - (x<<1)，具体得看compiler的智商
     - 除法运算很慢，但是除以2的幂可以转化成移位

---

习<span id = "习题">题</span>

- 练习2.5,11,12,13,15,23,25,26

  ```c
  #include<stdio.h>
  #include<string.h>
  typedef unsigned char* byte_pointer;
  
  /*练习2.5
   *练习2.11很容易。原因是两个指针指向了相同的地址。 
   *练习2.12 
   *练习2.13
   *(1)bis(x,y)
   *(2)bis( bic(x,y), bic(y,x) )
   *练习2.15 !(x^y), 通过异或性质(元素加法逆元为自身)
   *练习2.23 保留最后8位, 得到其表示的数值的signed形式(通常都会是算术位移，前面有练习证明了算术位移不会改变signed类型的数值) 
   *练习2.25 由于length的类型为unsigned, 所以当length为0时，length-1并不是-1, 会访问a为基地址的之后的所有内存
   *练习2.26 直接对两个string的strlen进行比较即可, 否则会因为它们的差小于0导致溢出 
   */
  	 
  
  void show_byte(byte_pointer start, size_t len)
  {
  	size_t i;
  	for(i = 0; i < len; ++i)
  	{
  		printf("%.2x", start[i]);
  	}
  	printf("\n");
  }
  
  void show_int(int x)
  {
  	show_byte((byte_pointer) &x, sizeof(int));
  }
  
  void show_float(float x)
  {
  	show_byte((byte_pointer) &x, sizeof(float));
  }
  
  void show_int(void* x)
  {
  	show_byte((byte_pointer) &x, sizeof(void*));
  }
  
  void change_1(byte_pointer x, int len)
  {
  	for(size_t i = 1; i < len; ++i)
  	{
  		x[i] = 0;
  	}
  }
  
  void change_2(byte_pointer x, int len)
  {
  	for(size_t i = 1; i < len; ++i)
  	{
  		x[i] = ~x[i];
  	}
  }
  
  void change_3(byte_pointer x)
  {
  	x[0] = 0xff;
  }
  
  
  
  int main()
  {
  	int val = 0x87654321;
  	byte_pointer valp = (byte_pointer)&val;
  	change_2(valp, sizeof(int));
  	printf("%d\n", val);//可以确定储存方式是low endian 
  	show_byte(valp, 1);
  	show_byte(valp, 2);
  	show_byte(valp, 3);
  	
  	const char* s = "abcdef";
  	show_byte((byte_pointer)&s, strlen(s));
  	return 0;
  }
  
  //小端法表示 
  ```

- 练习2.29, 30, 31, 32, 36,37, 42,43

  ```C
  #include<bits/stdc++.h>
  using namespace std;
  
  //练习2.29和2.30
  //练习2.31 这个函数的返回值永远是1
  //练习2.32 同tadd_ok的条件。原来的代码会在参数为-1, -2147483648时出错 
  //练习2.36 判断int64_t转换为int发生截断时是否对数值造成影响 
  //练习2.37 不会解决, 我的建议是不要解决, 分配空间太大直接报错 
  //练习2.42 要考虑怎么才能直接获得bias(考虑掩码过滤) 
  //练习2.43 N=8, M=31 
  
  //用减法替代加法 
  int uadd_ok(unsigned x, unsigned y)
  {
  	if(0xffffffff-x>=y)
  		return 1;
  	else return 0;
  }
  
  int tadd_ok(int x, int y)
  {
  	if((x > 0 && y > 0 && x+y < 0) || (x < 0 && y < 0 && x+y > 0))
  		return 0;
  	return 1;
  }
  
  int tmult_ok(int x, int y)
  {
  	int64_t judge = (int64_t)x*y;
  	if(judge == int(judge))
  		return 1; 
  	return 0;
  }
  
  int div16(int num)
  {
  	int bias = (num >> 31) & 0xF;
  	return (num+bias) >> 4;
  }
  
  int main()
  {
  	cout << div16(-17);
  	return 0;
  }
  ```

  